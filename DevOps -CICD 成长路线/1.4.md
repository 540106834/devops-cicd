好，这次我把**第 4 周**拆到「**每天你具体要干什么、敲什么、看什么现象、为什么这么干**」，做到**照着抄就能练成**。
你把它当成一份 **DevOps 实操实验手册** 

---

#  第 4 周：完整 CI 流水线实操（Day 22–30 超详细版）

> 本周一句话目标：
> **把 CI 从“会写 YAML”变成“能交付结果的流水线”**

---

#  Week 4 总体认知地图（先刻进脑子）

```
触发方式
  ↓
Runner（环境）
  ↓
Job（命令）
  ↓
Stage（顺序）
  ↓
Artifacts（结果）
```

CI 本质就是：
 **自动在一台临时机器上执行你平时手敲的命令**

---

#  Day 22：CI Runner 到底是谁在跑命令（地基日）

##  今日目标

* 彻底理解：**CI 不是在 Git 仓库里跑**
* 明白为什么 CI 环境“什么都没有”

---

## ① 你今天要做什么

### 1 新建一个最简单的 pipeline

```yaml
test-job:
  script:
    - pwd
    - ls -la
    - whoami
```

---

### 2 观察 CI 日志，重点看

你会看到类似：

```
Running on runner-xxxxx
/home/gitlab-runner/builds/xxx/xxx
```

---

## ② 今天必须理解的 3 个结论

✅ Job 跑在 **Runner 上**
不是你电脑，不是 Git 服务器

✅ Runner 每次都是 **新环境**

* 没有 node_modules
* 没有你本地装的软件

✅ CI = 自动 ssh 到一台临时机器执行命令

---

##  今日验收

你能回答：

> 为什么 CI 里总要重新 install 依赖？

---

#  Day 23：Stage + 多 Job（流水线成型）

##  今日目标

* 明白 job 为什么要拆
* 理解“并行”和“顺序”

---

## ① 写一个真正有结构的 pipeline

```yaml
stages:
  - test
  - build
```

```yaml
lint-job:
  stage: test
  script:
    - echo lint

unit-test-job:
  stage: test
  script:
    - echo unit test
```

```yaml
build-job:
  stage: build
  script:
    - echo build
```

---

## ② 观察现象（很重要）

* lint-job 和 unit-test-job **同时跑**
* build-job **等 test 全部成功才跑**

---

## ③ 为什么要拆 job

❌ 一个 job 写 100 行 script
✅ 每个 job 只干一件事

好处：

* 快
* 好排查
* 好重跑

---

##  今日验收

你能解释：

> 为什么 test 阶段失败，build 不该执行？

---

#  Day 24：Artifacts（CI 开始“有产出”）

##  今日目标

* 知道 CI 不是只打印 log
* 会保存文件

---

## ① 写一个能生成文件的 job

```yaml
build-job:
  stage: build
  script:
    - mkdir dist
    - echo "hello ci" > dist/app.txt
```

---

## ② 加上 artifacts

```yaml
artifacts:
  paths:
    - dist/
```

完整：

```yaml
build-job:
  stage: build
  script:
    - mkdir dist
    - echo "hello ci" > dist/app.txt
  artifacts:
    paths:
      - dist/
```

---

## ③ 你要亲自做的事

* 跑 pipeline
* 点击 artifacts
* 下载
* 打开 `app.txt`

---

## ④ 非常重要的理解

❌ artifacts ≠ 提交到 git
✅ artifacts = pipeline 的“临时产物”

以后：

* Docker 镜像
* 构建包
* 测试报告
  都是 artifacts 思路

---

##  今日验收

你能回答：

> artifacts 为什么不会永久保存？

---

#  Day 25：变量 + 参数化（从写死到灵活）

##  今日目标

* 同一条 pipeline 适配不同环境

---

## ① 使用变量

```yaml
variables:
  ENV: dev
```

```yaml
script:
  - echo "deploy to $ENV"
```

---

## ② 修改变量观察变化

```yaml
variables:
  ENV: test
```

---

## ③ 为什么变量这么重要

如果没有变量：

```yaml
echo deploy to dev
```

你将来会遇到：

* dev
* test
* staging
* prod

变量是 **规模化 CI 的钥匙**

---

##  今日验收

你能解释：

> 为什么不能为每个环境写一套 YAML？

---

#  Day 26：失败控制（生产意识）

##  今日目标

* 明白 CI 什么时候会停
* 知道失败会造成什么后果

---

## ① 人为制造失败

```yaml
script:
  - echo start
  - false
  - echo never-run
```

---

## ② 观察日志

* `false` 执行后
* job 立即失败
* 后面的命令不再执行

---

## ③ 失败的真实意义

在生产里：

* test 失败 → 禁止交付
* build 失败 → 没有产物
* deploy 失败 → 业务风险

CI 是 **自动刹车系统**

---

##  今日验收

你能说清：

> CI 为什么“宁可失败，也不能放行”？

---

#  Day 27：Manual Job（人类介入）

##  今日目标

* 理解 CD 为什么要“点按钮”

---

## ① 写一个手动 job

```yaml
deploy-job:
  stage: build
  script:
    - echo deploy prod
  when: manual
```

---

## ② 观察 pipeline

* pipeline 停住
* 显示一个 ▶ 按钮
* 不点就不会继续

---

## ③ 为什么生产一定要 manual

* 防止误触发
* 给人确认窗口
* 留 rollback 时间

---

##  今日验收

你能解释：

> 为什么测试环境自动，生产环境手动？

---

#  Day 28–29：整合一条「像样的」流水线

##  最终实战模板（你要完全看懂）

```yaml
stages:
  - test
  - build
  - deploy
```

```yaml
test-job:
  stage: test
  script:
    - echo run test
```

```yaml
build-job:
  stage: build
  script:
    - mkdir dist
    - echo app > dist/app.txt
  artifacts:
    paths:
      - dist/
```

```yaml
deploy-job:
  stage: deploy
  script:
    - echo deploy app
  when: manual
```

---

## 你要做到

* 能改 stage 顺序
* 能加一个新 job
* 能看日志定位问题

---

#  Day 30：终极自检（决定你是不是入门）

你必须能**不查资料**回答：

1 pipeline 是谁触发的
2 job 在哪里执行
3 artifacts 用来干嘛
4 为什么生产要 manual

如果全答对：
 **你已经是 CI 实操入门水平**

---

#  一句话心法（送你）

> **CI 就是一台听话的临时机器**
> **YAML 是你给它的作业本**

---

## 下一步你可以选 

1 我帮你把 **第 4 周整理成打卡清单版**
2 直接进入 **第 5 周：Docker + CI（真正值钱的部分）**
3 用你现在的理解，**我给你一套 DevOps 面试题对照表**

你选一个，我继续带你往前走 
