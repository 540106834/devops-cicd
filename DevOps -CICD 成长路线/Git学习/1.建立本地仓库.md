#  建立本地 Git 仓库（逐步实操 + 原理说明）

> 场景设定：你从一个**普通目录**，一步步把它变成一个**可版本控制的仓库**

------

##  第一步：准备一个普通目录

`安装git，准备普通目录`

## 第二步：初始化 Git 仓库（最关键一步）

##### 把当前目录升级为 Git 仓库:

```bash
$ git init
Initialized empty Git repository in E:/github/git-test/.git/
```

具体做了 4 件事：

#### 1 创建 `.git` 目录（Git 的大脑）

```bash
$ ls -a
.git
$ ls .git/
HEAD  config  description  hooks/  info/  objects/  refs/

```

```
$ cat .git/HEAD
ref: refs/heads/master

# HEAD为当前指针，告诉 Git：我现在站在哪儿
# 含义：HEAD 指向当前分支，它不是直接指向某个 commit，而是指向一个“引用”
# 直觉理解：HEAD 就像你的 GPS 定位，“你现在在哪个分支的最新位置”。
```

```
$ cat .git/config
[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
     
# config 仓库级配置文件
# 里面通常有：仓库名，远程仓库地址，分支与远程的关联关系
# 这个仓库的“个性设置”，只影响当前仓库。
```

```
$ cat .git/description
Unnamed repository; edit this file 'description' to name the repository.

# 给 GitWeb / 服务端看的描述文件
# 历史遗留文件，本地开发几乎用不到，可以忽略。
```

```
$ ls .git/hooks/
applypatch-msg.sample*      pre-push.sample*
commit-msg.sample*          pre-rebase.sample*
fsmonitor-watchman.sample*  pre-receive.sample*
post-update.sample*         prepare-commit-msg.sample*
pre-applypatch.sample*      push-to-checkout.sample*
pre-commit.sample*          sendemail-validate.sample*
pre-merge-commit.sample*    update.sample*

# 钩子脚本目录，Git 的“条件反射系统”，这些脚本可以在特定动作前后自动执行。
# 直觉理解：像是“进门前检查工牌”，比如：提交前跑单元测试，阻止不规范提交
```

```
$ ls .git/info/
exclude

# info/ 排除规则等零碎信息
# 作用类似 .gitignore，但：只对当前仓库有效,不会提交到远程
# 直觉理解：你的私人忽略清单。
```

```
$ ls .git/objects/
info/  pack/

# 真正存数据的地方，Git 的数据库
```

```
$ ls .git/refs/
refs/
 ├─ heads/      # 本地分支
 ├─ remotes/    # 远程分支
 └─ tags/       # 标签
 
# 直觉理解：refs 是“路标”，而 commit 是“地点”。
```

**Git = objects（数据） + refs（指针） + HEAD（当前位置）**

⚠️ **删了 `.git`，相当于降级目录为普通目录**

------

#### 2 创建默认分支（main / master）

```bash
$ cat .git/HEAD
ref: refs/heads/main
```

含义：`HEAD` 指向当前分支,但此时还 **没有任何提交**

------

#### 3 仓库状态变为「可追踪」

```bash
$ git status
On branch main
No commits yet
nothing to commit
```

这说明：Git 已经接管这个目录,但仓库是**空的**

------

#### 4 建立三层结构模型（非常重要）

从这一刻起，目录里有了 3 个世界：

```
工作区（你看到的文件）  # 未被 Git 接管的现实世界
   ↓ git add
暂存区（Index）       # 准备提交的内容清单
   ↓ git commit
本地仓库（.git）      # 不可变的历史记录
```

------

## 第三步：创建文件（工作区）

```bash
$ echo "Hello Git" > readme.txt
$ git status
On branch master
No commits yet
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        readme.txt
nothing added to commit but untracked files present (use "git add" to track)

# 说明
- 文件存在于 工作区
- Git 知道你创建了文件
- 但还没纳入版本控制
```

------

## 第四步：加入暂存区（git add）

```bash
$ git add readme.txt

# - Git 把当前文件内容拍了一张“快照”
# - 放进 **暂存区（Index）**
```

### 状态查看

```bash
$ git status
On branch master
No commits yet
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   readme.txt
        
# 暂存区 = **本次提交的候选清单**
```

---

## 第五步：提交到本地仓库（git commit）

```bash
$ git commit -m "first commit"
[master (root-commit) 85a9479] first commit
 1 file changed, 1 insertion(+)
 create mode 100644 readme.txt

# 1.创建一个 commit 对象,包含：
- 提交人
- 时间
- 提交说明
- 文件快照指针

# 2.分支指针前移
main → commit_001
HEAD → main

# 3.仓库不再是空的
$ git log
commit 85a94799463d759ba867b3582d607b1514923f1e (HEAD -> master)
Author: 540106834 <540106834@qq.com>
Date:   Wed Dec 24 23:03:17 2025 +0900

    first commit

```



## 此时你已经拥有了什么？

 一个本地 Git 仓库
 一次完整提交历史
 一个分支
 可回滚、可对比、可协作的基础

------

## 全流程一眼看懂（终极图）

```
① mkdir git-demo
   ↓
② git init
   ↓
③ 创建文件（工作区）
   ↓
④ git add（暂存区）
   ↓
⑤ git commit（本地仓库）
```

------

##  常见误区（新手必踩）

##### 误区 1：以为 git init 就算提交了

> 实际：只是建了仓库，**历史还是空的**

##### 误区 2：改了文件却没 add

> commit 的是**旧版本**

##### 误区 3：删 `.git` 想“重来”

> 等于把整个项目历史抹掉

------

**Git 判断变化的本质： 对文件内容计算哈希，是否和记录的哈希一致**

**分支 = 一个指向某个 commit 的可移动指针**

**`HEAD` 是一个“指向指针的指针”**





## 学到这里你已经超过 70% 新手

如果你愿意，下一步我可以帮你继续拆：

-  **修改文件后 Git 是如何判断变化的**
-  **分支在 Git 内部其实只是一个指针**
-  **reset / revert / checkout 的本质区别**
-  **用真实运维场景讲 Git（配置回滚 / 灰度）**

