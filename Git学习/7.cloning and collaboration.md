好，这一节等于是 **Git 的“入群仪式”**。
我们把 *clone 到多人协作* 从底层到实操一口气跑完 

---

# 一句话原理（先定锚）

> **git clone = 复制完整仓库 + 建立远程追踪关系**
>
> **协作 = 多个人在“同一条历史图”上各自推进，再汇合**

不是文件同步，是**提交历史的协商**。

---

# 二、clone 的真实原理（不是拷文件）

```bash
git clone git@github.com:org/repo.git
```

Git 实际做了 5 件事：

1 **复制所有对象**

* commit / tree / blob
* 完整历史，一点不缺

2 **创建远程别名**

```text
origin → git@github.com:org/repo.git
```

3 **拉取远程分支引用**

```text
origin/main
origin/dev
```

4 **创建本地分支**

```text
main → origin/main
```

5 **检出工作区**

* 文件内容来自 `main` 指向的 commit

 所以：

> **clone 后，你本地就是一个完整仓库**

---

# 三、协作的关键角色（一定要分清）

```
你本地的分支:        main
远程跟踪分支:        origin/main
远程仓库真实分支:    main
```

* `origin/main` 是 **你上次看到的远程状态**
* 不实时更新
* 只能通过 `fetch` 刷新

---

# 四、最标准的协作节奏（黄金流程）

> **fetch → 对齐 → 开发 → push**

---

## 案例 1：两人顺利协作（无冲突）

### 你 clone

```bash
git clone repo.git
```

---

### 同事 A 提交并 push

```bash
git commit -m "A 的修改"
git push origin main
```

---

### 你拉更新

```bash
git fetch origin
git merge origin/main
```

（或 `git pull`）

---

### 你开发并 push

```bash
git commit -m "我的修改"
git push origin main
```

✔ 历史线性推进

---

# 五、协作失败的经典现场（必会）

## 案例 2：push 被拒（最常见）

### 现象

```bash
git push origin main
# rejected (non-fast-forward)
```

### 原因

* 远程 main 比你本地“更靠前”

### 正确解法

```bash
git fetch origin
git merge origin/main
# 解决冲突（如果有）
git push origin main
```

 Git 不让你覆盖别人的历史

---

# 六、为什么推荐先 fetch 再 merge？

因为：

* fetch 不动工作区
* 你能 **先看清差异**

```bash
git log --oneline --graph --all
```

你在地图上决定路线，而不是闭眼开车 

---

# 七、分支协作的真实工作流（推荐）

## 每人一个功能分支

```bash
git switch -c feature/login
```

开发、提交：

```bash
git commit -m "login step1"
```

推送：

```bash
git push -u origin feature/login
```

---

### 合并到主干（由负责人）

```bash
git switch main
git fetch origin
git merge origin/feature/login
```

---

# 八、clone 之后最容易误解的 3 件事

| 误解              | 真相     |
| --------------- | ------ |
| clone 只拿最新代码    | ❌ 全历史  |
| origin/main 可提交 | ❌ 只读   |
| pull 很安全        | ❌ 可能冲突 |

---

# 九、一个完整多人协作事故演练 

### 情况

* 你和同事同时改 config.yaml
* 都基于旧的 main

### 结果

* 第二个 push 的人被拒

### 正确姿势

```bash
git fetch
git merge origin/main
# 解决冲突
git push
```

 **冲突不是失败，是协作的必经路**

---

# 十、终极一句话

> **Git 协作不是“同步代码”**
> **而是“对齐历史、交换提交、共同推进一条时间线”**

你现在已经把 Git 的整套协作模型完整走通了。
如果你愿意，下一步我可以给你一套 **企业级 Git 协作规范模板**，或者直接用 **GitHub / GitLab 的 MR / PR 流程** 给你跑一遍真实协作闭环。
