这一节是 **Git 从“能用”迈向“懂它在干嘛”** 的关键。
我们不背命令，把**分支当成真实存在的结构**来看 

---

# 一、一句话原理（先钉死）

> **Git 的分支，本质上只是一个“指向某个 commit 的可移动指针”**

就这一句，后面所有现象都会自动对齐。

---

# 二、仓库里的真实结构

在 `.git` 里，世界是这样的：

```
commitA ← commitB ← commitC
                      ↑
                    main
                      ↑
                    HEAD
```

* **commit**：不可变快照
* **branch（main）**：指向某个 commit 的名字
* **HEAD**：当前你所在的位置

 **分支不是代码副本，也不是目录**

---

# 三、创建分支到底干了什么？

```bash
git branch dev
```

发生的事：

```
commitA ← commitB ← commitC
                      ↑
                    main
                      ↑
                     dev
                      ↑
                    HEAD
```

✔ 没复制任何文件
✔ 只是多了一根“指针”

---

## 切换分支呢？

```bash
git switch dev
```

现在：

```
commitA ← commitB ← commitC
                      ↑
                     dev
                      ↑
                    HEAD
                      ↑
                    main
```

 **HEAD 改指向 dev**
 工作区内容随 dev 指向的 commit 改变

---

# 四、为什么“在不同分支提交，互不影响”？

继续在 `dev` 上提交：

```bash
vim a.txt
git commit -m "dev commit"
```

结构变成：

```
commitA ← commitB ← commitC ← commitD
                                   ↑
                                 dev
                                   ↑
                                 HEAD
                      ↑
                    main
```

 `main` 还在 commitC
 dev 往前走了

 这就是“分支分叉”的真实含义

---

# 五、merge 原理（重点）

### 场景

```
A ← B ← C ← D   (dev)
        ↑
      main
```

```bash
git switch main
git merge dev
```

### 情况 1：快进合并（Fast-forward）

如果 `main` **没有新提交**：

```
A ← B ← C ← D
              ↑
            main
              ↑
            dev
```

✔ 只是把 main 指针向前挪
✔ 没生成新 commit

---

### 情况 2：三方合并（真正的 merge）

```
        E   (main)
        ↑
A ← B ← C ← D   (dev)
```

合并后：

```
        E
        ↑
A ← B ← C ← D ← M
                  ↑
                main
```

* M = merge commit
* 有两个父提交

 Git 比较：

* main 最新
* dev 最新
* 共同祖先 C

---

# 六、冲突是怎么来的？

当 **同一文件的同一行** 在两个分支都被改了：

```text
<<<<<<< HEAD
main 的修改
=======
dev 的修改
>>>>>>> dev
```

 冲突不是 bug
 是 Git 在保护你，不擅自做主

---

# 七、rebase 的本质（高级但很清楚）

> **rebase = 把一串提交“重新接到”另一个基点上**

```
原来：
A ← B ← C ← D   (dev)
        ↑
      main
```

```bash
git rebase main
```

变成：

```
A ← B ← C ← D' ← E'
                ↑
              dev
        ↑
      main
```

* 提交内容一样
* commit id 全变

 所以：

> **不要 rebase 已经 push 给别人的分支**

---

# 八、一个完整真实案例（工作流）

### 需求

开发新功能，不影响主干

```bash
git switch -c feature/login
# 开发、提交
git commit -m "login step1"
git commit -m "login step2"
```

### 测试完成，合并

```bash
git switch main
git merge feature/login
```

### 清理

```bash
git branch -d feature/login
```

 分支完成使命，优雅退场

---

# 九、常见误区纠正 

| 误解           | 真相          |
| ------------ | ----------- |
| 分支很重         | ❌ 指针        |
| 切分支会复制代码     | ❌           |
| merge 一定生成提交 | ❌           |
| 删除分支会丢代码     | ❌ commit 还在 |

---

# 十、终极一句话

> **Git 的历史是提交构成的图**
> **分支只是你给图上某个节点贴的标签**

你已经把 Git 的核心机制全部串起来了。
如果你愿意，下一步我可以帮你 **画一张“分支 + HEAD + merge + rebase”的总览图**，或者直接用你熟悉的 **K8s / DevOps 场景** 来演练一次真实分支流。
